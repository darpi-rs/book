<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Web Asynchronous Programming in Rust with darpi</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_getting_started/01_chapter.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_getting_started/02_why_darpi.html"><strong aria-hidden="true">1.1.</strong> Why Darpi?</a></li><li class="chapter-item expanded "><a href="01_getting_started/03_state_of_web_frameworks.html"><strong aria-hidden="true">1.2.</strong> The State of Web Frameworks</a></li></ol></li><li class="chapter-item expanded "><a href="02_basics/01_chapter.html"><strong aria-hidden="true">2.</strong> Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_basics/02_app.html"><strong aria-hidden="true">2.1.</strong> App</a></li><li class="chapter-item expanded "><a href="02_basics/03_handlers.html"><strong aria-hidden="true">2.2.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="02_basics/04_errors.html"><strong aria-hidden="true">2.3.</strong> Errors</a></li><li class="chapter-item expanded "><a href="02_basics/05_middleware.html"><strong aria-hidden="true">2.4.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="02_basics/06_jobs.html"><strong aria-hidden="true">2.5.</strong> Jobs</a></li><li class="chapter-item expanded "><a href="02_basics/07_web_sockets.html"><strong aria-hidden="true">2.6.</strong> Web sockets</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Web Asynchronous Programming in Rust with darpi</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>If you're looking to start writing simple, productive, safe and fast web backends
, you've come to the right place.</p>
<h2><a class="header" href="#what-this-book-covers" id="what-this-book-covers">What This Book Covers</a></h2>
<p>This book aims to be a comprehensive, up-to-date guide to using the web
framework <code>darpi</code> and the crates associated with it, appropriate for beginners and old hands alike.</p>
<h2><a class="header" href="#a-a-hrefhttpsgithubcomdarpi-rsexample-heroku-darpidemo-appa-to-check-out" id="a-a-hrefhttpsgithubcomdarpi-rsexample-heroku-darpidemo-appa-to-check-out">A <a href="https://github.com/darpi-rs/example-heroku-darpi">demo app</a> to check out</a></h2>
<p>Let's go ahead!</p>
<h1><a class="header" href="#why-darpi" id="why-darpi">Why darpi?</a></h1>
<p>We all love how Rust allows us to write fast, safe software.
<code>darpi</code> attempts at extending that and having stronger invariants proven that are specific to the web.</p>
<p>Performance, safety and simplicity are the main goals the framework is trying to achieve.</p>
<p>Applications built with <code>darpi</code> have the potential to be much faster and
use fewer resources than other frameworks. To achieve its goals, <code>darpi</code> utilizes macros, heavily.</p>
<h1><a class="header" href="#the-state-of-rust-web-frameworks" id="the-state-of-rust-web-frameworks">The State of Rust web frameworks</a></h1>
<p>While some great web frameworks are out there, there is room for another point of view.
Some of them are either not very flexible, too complicated, pushed compile time errors to runtime by using
the type <code>std::any::Any</code> or all of the above.</p>
<p>With continuation of the Rust way, we would have to extend the Rust guarantees:</p>
<ul>
<li>Outstanding runtime performance for concurrent workloads.</li>
<li>Flexible, testable and composable software.</li>
<li>Minimizing runtime errors, as much as possible.</li>
<li>Simplicity.</li>
</ul>
<h1><a class="header" href="#basics" id="basics">Basics</a></h1>
<p><code>darpi</code> provides various primitives to build web servers and applications with Rust. It provides routing, middleware, pre-processing of requests, post-processing of responses, etc.</p>
<p><code>darpi</code> uses <code>shaku</code> for statically verifiable dependency injection, since it is alligned with the goals <code>darpi</code> has.</p>
<p>It is important to note that <code>darpi</code> does not store dynamic information about the application.
Everything is achieved by code generation. For example, the provided routes are represented by an enum variants used in a match statement.</p>
<p><code>darpi</code> solves conflicting paths by sorting, based on different of factors such as number of arguments in
a path and their position within the string.</p>
<p><code>/user/{name}</code> and <code>/user/article</code> are conflicting, if a user's name happens to be <code>article</code>. Therefore, the more generic path should be matched later.</p>
<h1><a class="header" href="#app" id="app">App</a></h1>
<p>The <code>app</code> macro generates code that link all the other components together. </p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;(), darpi::Error&gt; {
    let address = format!(&quot;127.0.0.1:{}&quot;, 3000);
    app!({
        address: address,
        container: {
            factory: make_container(),
            type: Container
        },
        middleware: {
            request: [body_size_limit(128), decompress()],
            response: []
        },
        jobs: {
            request: [],
            response: [first_sync_job, first_sync_job1, first_sync_io_job]
        },
        handlers: [
            {
                route: &quot;/&quot;,
                method: Method::GET,
                handler: home
            },
        ]
    })
    .run()
    .await
}
</code></pre></pre>
<p>Lets break it down.</p>
<p><code>address</code> can be either a <code>String</code> or a <code>&amp;'static str</code></p>
<p><code>container</code> has a <code>factory</code> function, which is used to create a <code>shaku</code> container
and a <code>type</code> (supports arguments too), which is the return type of the <code>factory</code>.</p>
<p><code>middleware</code>, <code>jobs</code> and <code>handlers</code> we will tackle in the next chapters.</p>
<h1><a class="header" href="#handlers" id="handlers">Handlers</a></h1>
<p>The <code>handler</code> macro has 3 optional arguments in a json like format.
Trailing commas are not supported as of now.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler({
    container: Container,
    middleware: {
        request: [],
        response: []
    },
    jobs: {
        request: [],
        response: []
    }
})]
<span class="boring">}
</span></code></pre></pre>
<p>A request handler is an async function that accepts zero or more arguments.
The arguments can be provided in several ways, by macro attributes.
Handlers bound by a <code>GET</code> method do not have access to a request body.
The return type must <code>impl darpi::response::Responder</code>. For convenience, it is implemented for all common types.</p>
<p>##possible arguments</p>
<ul>
<li>dependency injection container
<ul>
<li><code>#[inject] my_arg: Arc&lt;dyn SomeTrait&gt;</code></li>
</ul>
</li>
<li>request
<ul>
<li><code>#[request] r: darpi::Request&lt;darpi::Body&gt;</code> consumes the entire request therefore prevents other attributes from being used except <code>#[path]</code> </li>
<li><code>#[request_parts] rp: &amp;darpi::RequestParts</code></li>
<li><code>#[query] q: MyStruct</code> where <code>MyStruct</code> has to implement
<code>serde::Deserialize</code>. Furthermore, if wrapped in an <code>Option</code> it is not mandatory.</li>
<li><code>#[path] path: MyStruct</code> where <code>MyStruct</code> has to implement
<code>serde::Deserialize</code>. <code>/user/{id}/article/{id}</code> will deserialize both ids into <code>MyStruct</code>.</li>
<li><code>#[body] data: impl FromRequestBody&lt;T: serde:Deserialize&gt;</code> if handler is not linked to a <code>GET</code> request</li>
</ul>
</li>
<li>middleware
<ul>
<li><code>#[middleware::request(i) my_arg: T]</code> where <code>i</code> is a literal index of the middleware linked to the handler</li>
<li><code>#[middleware::response(i) my_arg: T]</code> does not exist (obviously), because response middleware runs after the handler returns</li>
</ul>
</li>
</ul>
<p>While i recommend using the macros. If you really want to, you could implement the handler trait.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use darpi_middleware::body_size_limit;
use darpi::{app, handler, response::Responder, Method, Path, Json, Query};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug, Path, Query)]
pub struct Name {
    name: String,
}

#[handler({
    middleware: {
        // roundtrip returns Result&lt;String, Error&gt;
        // later we can access it via #[middleware::request(0)]
        request: [roundtrip(&quot;blah&quot;)]
    }
})]
async fn do_something(
  #[request_parts] _rp: &amp;RequestParts,
  // the request query is deserialized into Name
  // if deseriliazation fails, it will result in an error response
  // to make it optional wrap it in an Option&lt;Name&gt;
  #[query] query: Name,
  // the request path is deserialized into Name
  #[path] path: Name,
  // the request body is deserialized into the struct Name
  // it is important to mention that the wrapper around Name
  // should implement darpi::request::FromRequestBody
  // Common formats like Json, Xml and Yaml are supported out
  // of the box but users can implement their own
  #[body] payload: Json&lt;Name&gt;,
  // we can access the T from Ok(T) in the middleware result
  #[middleware::request(0)] m_str: String, // returning a String works because darpi has implemented
  // the Responder trait for common types
) -&gt; String {
  format!(
    &quot;query: {:#?} path: {} body: {} middleware: {}&quot;,
    query, path.name, payload.name, m_str
  )
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#errors" id="errors">errors</a></h1>
<p>Any error implementing the <code>ResponderError</code> trait can be used in a handler return type.
In this case, we are using the default implementation of the trait.</p>
<pre><code class="language-rust ignore">use darpi::response::ResponderError;

#[derive(Display, Debug)]
pub enum Error {
    #[display(fmt = &quot;wrong credentials&quot;)]
    WrongCredentialsError,
    #[display(fmt = &quot;jwt token not valid&quot;)]
    JWTTokenError,
    #[display(fmt = &quot;jwt token creation error&quot;)]
    JWTTokenCreationError,
    #[display(fmt = &quot;no auth header&quot;)]
    NoAuthHeaderError,
    #[display(fmt = &quot;invalid auth header&quot;)]
    InvalidAuthHeaderError,
    #[display(fmt = &quot;no permission&quot;)]
    NoPermissionError,
}

impl ResponderError for Error {}

#[derive(Deserialize, Serialize, Debug)]
pub struct Login {
    email: String,
    password: String,
}

#[handler(Container)]
async fn login(
    #[body] data: Json&lt;Login&gt;,
    #[inject] jwt_tok_creator: Arc&lt;dyn JwtTokenCreator&gt;,
) -&gt; Result&lt;Token, Error&gt; {
    //verify user data
    let admin = Role::Admin; // hardcoded just for the example
    let uid = &quot;uid&quot;; // hardcoded just for the example
    let tok = jwt_tok_creator.create(uid, &amp;admin).await?;
    Ok(tok)
}
</code></pre>
<h1><a class="header" href="#middleware" id="middleware">middleware</a></h1>
<p>darpi’s middleware system allows us to add additional behavior to
request/response processing. Middleware can hook into an incoming request
process, enabling us to halt request processing to return a response early
and modify the request body.
Middleware can also hook into response processing.</p>
<h4><a class="header" href="#middleware-types" id="middleware-types">middleware types</a></h4>
<ul>
<li>global (app)
<ul>
<li>Request</li>
<li>Response</li>
</ul>
</li>
<li>local (handler)
<ul>
<li>Request</li>
<li>Response</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#possible-arguments" id="possible-arguments">possible arguments</a></h3>
<ul>
<li>
<p>Request middleware</p>
<ul>
<li>dependency injection container
<ul>
<li><code>#[inject] my_arg: Arc&lt;dyn SomeTrait&gt;</code></li>
</ul>
</li>
<li>request
<ul>
<li><code>#[request] rp: &amp;mut darpi::Request&lt;darpi::Body&gt;</code> supports shared and mutable reference</li>
</ul>
</li>
<li>handler
<ul>
<li><code>#[handler] arg: T</code> where the value must be provided when the middleware is invoked</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Response middleware</p>
<ul>
<li>dependency injection container
<ul>
<li><code>#[inject] my_arg: Arc&lt;dyn SomeTrait&gt;</code></li>
</ul>
</li>
<li>response
<ul>
<li><code>#[response] r: &amp;mut darpi::Response&lt;Body&gt;</code> supports shared and mutable reference</li>
</ul>
</li>
<li>handler
<ul>
<li><code>#[handler] arg: T</code> where the value must be provided when the middleware is invoked</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>While i recommend using the macros. If you really want to, you could implement the middleware request and response traits.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use darpi::{middleware, request::PayloadError, Body, HttpBody};

#[middleware(Request)]
pub async fn body_size_limit(
  #[request] r: &amp;Request&lt;Body&gt;,
  #[handler] size: u64,
) -&gt; Result&lt;(), PayloadError&gt; {
  if let Some(limit) = r.size_hint().upper() {
    if size &lt; limit {
      return Err(PayloadError::Size(size, limit));
    }
  }
  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>a more complicated example</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[middleware(Request)]
pub async fn authorize(
  #[handler] role: impl UserRole,
  #[request] rp: &amp;Request&lt;Body&gt;,
  #[inject] algo_provider: Arc&lt;dyn JwtAlgorithmProvider&gt;,
  #[inject] token_ext: Arc&lt;dyn TokenExtractor&gt;,
  #[inject] secret_provider: Arc&lt;dyn JwtSecretProvider&gt;,
) -&gt; Result&lt;Claims, Error&gt; {
  let token_res = token_ext.extract(&amp;rp).await;
  match token_res {
    Ok(jwt) =&gt; {
      let decoded = decode::&lt;Claims&gt;(
        &amp;jwt,
        secret_provider.decoding_key().await,
        &amp;Validation::new(algo_provider.algorithm().await),
      ).map_err(|_| Error::JWTTokenError)?;

      if !role.is_authorized(&amp;decoded.claims) {
        return Err(Error::NoPermissionError);
      }

      Ok(decoded.claims)
    }
    Err(e) =&gt; return Err(e),
  }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#jobs" id="jobs">Jobs</a></h1>
<p><code>Jobs</code> represent some work packaged up in a function that the application
has to execute but it's not necessary to hold up the response to the user.
Just like <code>middleware</code>, <code>jobs</code> are bound to a <code>Request</code> or a <code>Response</code> and
utilize the same argument system as <code>middleware</code>.</p>
<p>We have 3 types of <code>jobs</code> based on their behaviour.
This is necessary to have an optimal way of using our resources.</p>
<ul>
<li>Job
<ul>
<li><code>Future</code> that does not block and does not perform any significant intensive work
. It is queued on the regular tokio runtime.</li>
<li><code>CpuBound</code> is a type of function that would do heavy computation and does not benefit from the tokio runtime.
We would execute those on the <code>Rayon</code> runtime that is optimized for that.</li>
<li><code>IOBlocking</code> is suitable for various kinds of IO operations that cannot be performed asynchronously.
It is executed on a separate tokio blocking threads.</li>
</ul>
</li>
</ul>
<p>While i recommend using the macros. If you really want to, you could implement the Job factory request and response traits.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Job&lt;T = ()&gt; {
    Future(FutureJob&lt;T&gt;),
    CpuBound(CpuJob&lt;T&gt;),
    IOBlocking(IOBlockingJob&lt;T&gt;),
}

pub struct FutureJob&lt;T = ()&gt;(Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send&gt;&gt;);
pub struct CpuJob&lt;T = ()&gt;(Box&lt;dyn FnOnce() -&gt; T + Send&gt;);
pub struct IOBlockingJob&lt;T = ()&gt;(Box&lt;dyn FnOnce() -&gt; T + Send&gt;);

<span class="boring">}
</span></code></pre></pre>
<p>Few short examples.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[job_factory(Request)]
async fn first_async_job() -&gt; FutureJob {
  async { println!(&quot;first job in the background.&quot;) }.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>// blocking here is ok!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[job_factory(Response)]
async fn first_sync_job(#[response] r: &amp;Response&lt;Body&gt;) -&gt; IOBlockingJob {
  let status_code = r.status();
  let job = move || {
    std::thread::sleep(std::time::Duration::from_secs(2));
    println!(
      &quot;first_sync_job in the background for a request with status {}&quot;,
      status_code
    );
  };
  job.into()
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[job_factory(Response)]
async fn my_heavy_computation() -&gt; CpuJob {
  let job = || {
    for _ in 0..100 {
      let mut r = 0;
      for _ in 0..10000000 {
        r += 1;
      }
      println!(&quot;my_heavy_computation runs in the background. {}&quot;, r);
    }
  };
  job.into()
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#web-sockets" id="web-sockets">Web sockets</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use darpi::futures::{SinkExt, StreamExt};
use darpi::{app, handler, job::FutureJob, response::UpgradeWS, Body, Method, Request};
use tokio_tungstenite::{tungstenite::protocol::Role, WebSocketStream};

#[handler]
async fn hello_world(#[request] r: Request&lt;Body&gt;) -&gt; Result&lt;UpgradeWS, String&gt; {
    let resp = UpgradeWS::from_header(r.headers())
        .ok_or(&quot;missing SEC_WEBSOCKET_KEY header&quot;.to_string())?;

    FutureJob::from(async move {
        let upgraded = darpi::upgrade::on(r).await.unwrap();
        let mut ws_stream = WebSocketStream::from_raw_socket(upgraded, Role::Server, None).await;

        while let Some(msg) = ws_stream.next().await {
            let msg = match msg {
                Ok(m) =&gt; m,
                Err(e) =&gt; {
                    println!(&quot;error trying to receive:  `{:#?}`&quot;, e);
                    return;
                }
            };

            if msg.is_text() || msg.is_binary() {
                println!(&quot;received a message `{}`&quot;, msg);
                if let Err(e) = ws_stream.send(msg).await {
                    println!(&quot;error trying to send:  `{:#?}`&quot;, e);
                    return;
                }
            } else if msg.is_close() {
                println!(&quot;closing websocket&quot;);
                return;
            }
        }
    })
        .spawn()
        .map_err(|e| format!(&quot;{}&quot;, e))?;

    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
